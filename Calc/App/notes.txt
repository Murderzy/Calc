git

VCS - Version Control System

Система обеспечивающая возвращение объекта в точку сохранения, 
система обеспечивает наличие "точек восстановления"
Git -- Github, Gitlab
Mercurial -- Bitbucket

-- сохраняются только изминения (добавление, удаление, изминение) -- commit -- архив изминений
-- НЕ принято добавлять в VCS: зависимости( пакеты, которые могут быть загруженны после установки 
	нашего проэкта), разультаты компиляции(exe, dll etc., промежуточные obj, cash), файлы БД(??),
	временные файлы(в том числе файлы-конфигы IDE("студии") - .vs, .idea)
-- все исключения прописываются в спец. файле .gitignore
	файл должен быть ориентирован на именно ту систему
	с которой идет работа("студия", язык программирования и т.д.). Универсального файла не существует
файл .gitignore может быть в каждой папке и влиять только на неё(включительно с подкаталогами)

Начало работы с VCS происходит по схеме:
- существует проэкт на локальном ПК, который нужно перенести  на Git
- существует проэкт на Git, который нужно перенести на локальный ПК

1: 
- убедиться, что на ПК установлены пакеты Git  Git (git-scm.com)
- или средствами "студии" или через консоль(терминал)
- git init - это создать в каталоге скрытую папку .git
- вносим изминения в код (работаем над кодом) 
- сохраняем изминения (commit название обязательно - commit all - push)
	-git add . - добавить текущую папку (все файлы )
	-git commit -m "text" - создаем коммит локально
	-git push --all -отправка в удаленный репозиторий

Конфликты появляются, когда изминения сделаны одновременно и при внесении изминений с одного ПК 
не учитыаются изминения сделанные на другом ПК

---------------


2:(для командной работы)
- хозяин проекта должен включить участника в него(дать доступ)
- участник проекта должен подтвердить участие в проекте(согласиться)
- клонирование проекта на локальный ПК

----------------------------------

Тестирование

Есть разные виды тестирования, акцент на модульное тестирование
Тесты(тестовые методы) - тематическое направление 
Группы тестов(тестовые классы) - способ группирования тестов
Подгруппы тестов - другие уровни иерархий
Основу тестов составляют утверждения (assert), которые проверяются и определяются как верные или нет
Если все утверждения верны, то тест считается пройденным 
Если хотя бы одно утверждение ложно - тест считается проваленным
В некоторых системах уведомления выводятся для каждого утверждения(для каждого вызова Assert)
В системе MSTest еденицей оповещений является тестовый метод (в котором может быть много Assert)

Как правило провал одного из тестов не останавливает процесс тестирования и другие тесты все равно проверяются
Разделение тестов на различные группы(методы) позволяет более качественно искать ошибки в работе модуля.

Кростест
Проверка совместной работы Parse и ToString 


----------------------------------------------
Рефакторинг - прием в программировании нацеленный на улучшение кода,
НО не изменяющий его алгоритимечкую часть.
!!! Рефакторинг не добавляет функциональность, не исправляет оишбки  - а только улучшает 
реализацию заданных алгоритмов.Изменения в алгоритмах вносит прием Оптимизация.
Рефакторинг в эсктремальном программировании играет особую роль. В силу того, что код пишется быстро, он содержит много
того, что можно будет улучшить
Цикл разработки в XP идет по схеме : [ТЗ] - тесты - [код] - рефакторинг. 
Если на конец цикла нету нового ТЗ, то цикл продолжается без него.

Игнорирование рефакторинга приводит к появлению 
"Технического долга"(Technical debt) - отложенных изменений в коде, которые его улучшают.

Код с большими "долгами" так же называют "код с запахом" и классифицируют недостатки кода, как "запахи".

Рефакторинг содержит набор правил по поиску недостатков  и рекомендаций по их устранению. Поэтому возможны
автоматизированные интсрументы рефаторинга. Однако их полностью автоматическое использование не приветсвтуется,
т.к. ряд критериев является интеллектуальным.

В противоположеость "коду с долгами" говорят о "чистом коде". Чистый код первоначально оценивают по
следующим критериям:
- понятен для других программистов
- проходит все тесты
- логично сгруппированный
	- нет дублирований(связанных дублирований, которые нужно менять синхронно)
	- минимализм - нет лишних "абстракций"
	- максимализм - нет "перегруженных"(больших) объединений

Рефакторинг - это комплекс действий по улучшению чистоты кода.

Методы(приёмы) рефакторинга: 
(-группы = набор :: методы)
-объекты(Классы) -- группа приемов, нацеленная на изменение в схеме(способе ) организации, группировке объектов, их классов
и интерфейсов
	= Объединение (Collapse)
	::Классов
	::Интерфейсов
	=Разъединение (декомпозиция)
	:: отделение подклассов
	:: отделение суперклассов
	:: разделение интерфейсов
	=Реорганизация(переопределение)
	::перемещение вверх
	::переиещение вниз
	::изменение связей и их типа(наследование/композиция/агрегация)


-сигнатуры -- приемы направленные на изминение в способах вызова функций,
				методов, передачи им параметров и возврате результатов
	= названия методов и видимости(public/private/protected)
		::скрытие метода
		::открытие метода
		::переименование метода(параметров)
	= изминения в параметрах 
		::добавление параметров
		::удаление параметров
		::группировка параметров (порядок или инкапсуляция - помещение в объект)
			fun(x,y,z) --> fun(Point3D)
	= изминения в возврате 
		::преобразование в фабрику (возврат объектов)
		:: исключение или(<--->) возврат ошибки
			void writeLog(f) throws Exception		vs		bool writeLog(f)
			{if(...)throw new Exc}							{if(...)return false;}
								main(){... writeLog(f);...}


-конструкции управления: приемы направленные на изминения в условиях и циклах
	= изминение конструкций ветвления
		::объединение условий/case
		::разъединение условий/case -- if(){if()}
		::инверсия условий (!x && !y <---> !(x||y))
		::замена if <---> switch
		::замена условных блоков полиморфизмом
			if(){do1();}else{do2();} ---> if(){new Obj1().do();}else{new Obj2().do();}
	= изминение цикловых конструкций
		::линеаризация <---> цикл (for(3){doSmth();} <---> doSmth();doSmth();doSmth();)
		::условные <--->счетчики

-данные
	= изминение типа
		::Reference <---> Value
		::Primitive ---> Object
		::Arrays <---> Objects
	= группирование
		::инкапсуляция
		::разделение
	= изменение связности
		::замена "магических чисел " на константы(int x *= 1.5; int x *= Max_Speed;)
		::замена констан на методы (const int PI = 3; ---> int Pi(){return 3;})
		::удаление связей "один - к - одному"

-код
	= изминение в группировании(без изминений тела)
		::инкапсуляция (методы -> объект)
		::разделение
		::отказ от метода(inline-методы)
		::перемещение по иерархии
		::перенос в прототип или в методы расширения
	= реорганизация(изминения тела)
		::разделение на несколько методов
		::соединение в один метод
		