git

VCS - Version Control System

Система обеспечивающая возвращение объекта в точку сохранения, 
система обеспечивает наличие "точек восстановления"
Git -- Github, Gitlab
Mercurial -- Bitbucket

-- сохраняются только изминения (добавление, удаление, изминение) -- commit -- архив изминений
-- НЕ принято добавлять в VCS: зависимости( пакеты, которые могут быть загруженны после установки 
	нашего проэкта), разультаты компиляции(exe, dll etc., промежуточные obj, cash), файлы БД(??),
	временные файлы(в том числе файлы-конфигы IDE("студии") - .vs, .idea)
-- все исключения прописываются в спец. файле .gitignore
	файл должен быть ориентирован на именно ту систему
	с которой идет работа("студия", язык программирования и т.д.). Универсального файла не существует
файл .gitignore может быть в каждой папке и влиять только на неё(включительно с подкаталогами)

Начало работы с VCS происходит по схеме:
- существует проэкт на локальном ПК, который нужно перенести  на Git
- существует проэкт на Git, который нужно перенести на локальный ПК

1: 
- убедиться, что на ПК установлены пакеты Git  Git (git-scm.com)
- или средствами "студии" или через консоль(терминал)
- git init - это создать в каталоге скрытую папку .git
- вносим изминения в код (работаем над кодом) 
- сохраняем изминения (commit название обязательно - commit all - push)
	-git add . - добавить текущую папку (все файлы )
	-git commit -m "text" - создаем коммит локально
	-git push --all -отправка в удаленный репозиторий

Конфликты появляются, когда изминения сделаны одновременно и при внесении изминений с одного ПК 
не учитыаются изминения сделанные на другом ПК

---------------


2:(для командной работы)
- хозяин проекта должен включить участника в него(дать доступ)
- участник проекта должен подтвердить участие в проекте(согласиться)
- клонирование проекта на локальный ПК

----------------------------------

Тестирование

Есть разные виды тестирования, акцент на модульное тестирование
Тесты(тестовые методы) - тематическое направление 
Группы тестов(тестовые классы) - способ группирования тестов
Подгруппы тестов - другие уровни иерархий
Основу тестов составляют утверждения (assert), которые проверяются и определяются как верные или нет
Если все утверждения верны, то тест считается пройденным 
Если хотя бы одно утверждение ложно - тест считается проваленным
В некоторых системах уведомления выводятся для каждого утверждения(для каждого вызова Assert)
В системе MSTest еденицей оповещений является тестовый метод (в котором может быть много Assert)

Как правило провал одного из тестов не останавливает процесс тестирования и другие тесты все равно проверяются
Разделение тестов на различные группы(методы) позволяет более качественно искать ошибки в работе модуля.

Кростест
Проверка совместной работы Parse и ToString 


----------------------------------------------
Рефакторинг - прием в программировании нацеленный на улучшение кода,
НО не изменяющий его алгоритимечкую часть.
!!! Рефакторинг не добавляет функциональность, не исправляет оишбки  - а только улучшает 
реализацию заданных алгоритмов.Изменения в алгоритмах вносит прием Оптимизация.
Рефакторинг в эсктремальном программировании играет особую роль. В силу того, что код пишется быстро, он содержит много
того, что можно будет улучшить
Цикл разработки в XP идет по схеме : [ТЗ] - тесты - [код] - рефакторинг. 
Если на конец цикла нету нового ТЗ, то цикл продолжается без него.

Игнорирование рефакторинга приводит к появлению 
"Технического долга"(Technical debt) - отложенных изменений в коде, которые его улучшают.

Код с большими "долгами" так же называют "код с запахом" и классифицируют недостатки кода, как "запахи".

Рефакторинг содержит набор правил по поиску недостатков  и рекомендаций по их устранению. Поэтому возможны
автоматизированные интсрументы рефаторинга. Однако их полностью автоматическое использование не приветсвтуется,
т.к. ряд критериев является интеллектуальным.

В противоположеость "коду с долгами" говорят о "чистом коде". Чистый код первоначально оценивают по
следующим критериям:
- понятен для других программистов
- проходит все тесты
- логично сгруппированный
	- нет дублирований(связанных дублирований, которые нужно менять синхронно)
	- минимализм - нет лишних "абстракций"
	- максимализм - нет "перегруженных"(больших) объединений

Рефакторинг - это комплекс действий по улучшению чистоты кода.

Методы(приёмы) рефакторинга: 
(-группы = набор :: методы)
-объекты(Классы) -- группа приемов, нацеленная на изменение в схеме(способе ) организации, группировке объектов, их классов
и интерфейсов
	= Объединение (Collapse)
	::Классов
	::Интерфейсов
	=Разъединение (декомпозиция)
	:: отделение подклассов
	:: отделение суперклассов
	:: разделение интерфейсов
	=Реорганизация(переопределение)
	::перемещение вверх
	::переиещение вниз
	::изменение связей и их типа(наследование/композиция/агрегация)


-сигнатуры -- приемы направленные на изминение в способах вызова функций,
				методов, передачи им параметров и возврате результатов
	= названия методов и видимости(public/private/protected)
		::скрытие метода
		::открытие метода
		::переименование метода(параметров)
	= изминения в параметрах 
		::добавление параметров
		::удаление параметров
		::группировка параметров (порядок или инкапсуляция - помещение в объект)
			fun(x,y,z) --> fun(Point3D)
	= изминения в возврате 
		::преобразование в фабрику (возврат объектов)
		:: исключение или(<--->) возврат ошибки
			void writeLog(f) throws Exception		vs		bool writeLog(f)
			{if(...)throw new Exc}							{if(...)return false;}
								main(){... writeLog(f);...}


-конструкции управления: приемы направленные на изминения в условиях и циклах
	= изминение конструкций ветвления
		::объединение условий/case
		::разъединение условий/case -- if(){if()}
		::инверсия условий (!x && !y <---> !(x||y))
		::замена if <---> switch
		::замена условных блоков полиморфизмом
			if(){do1();}else{do2();} ---> if(){new Obj1().do();}else{new Obj2().do();}
	= изминение цикловых конструкций
		::линеаризация <---> цикл (for(3){doSmth();} <---> doSmth();doSmth();doSmth();)
		::условные <--->счетчики

-данные
	= изминение типа
		::Reference <---> Value
		::Primitive ---> Object
		::Arrays <---> Objects
	= группирование
		::инкапсуляция
		::разделение
	= изменение связности
		::замена "магических чисел " на константы(int x *= 1.5; int x *= Max_Speed;)
		::замена констан на методы (const int PI = 3; ---> int Pi(){return 3;})
		::удаление связей "один - к - одному"

-код
	= изминение в группировании(без изминений тела)
		::инкапсуляция (методы -> объект)
		::разделение
		::отказ от метода(inline-методы)
		::перемещение по иерархии
		::перенос в прототип или в методы расширения
	= реорганизация(изминения тела)
		::разделение на несколько методов
		::соединение в один метод
		

-------------------------
Рефакторинг.Практика

1.Методы Add
	Ситуация: несколько методов Add(перегрузки) явно реализуют алгоритм сложения чисел(делегируют оператору +)
	Проблема: если понадобится изменить алгоритм сложения, то прийдется менять код во всех методах(дублировать изминения)
	Решение: реализовать алгоритм в одном методе, остальные перегрузки вызывают этот метод
	Add{x+y}Add{a+b}--->Add{x+y},Add(a,b){Add(x,y)}

2. Фабричность vs Полиморфизм
	Фабричность - создание объекта по разнообразным характеристикам
	MakeObject(object data)/ MakeObject(String name)
	Перегрузки - наличие множества методов под каждую из характеристик
	MakeObject(String name) / MakeObject(int name) / MakeObject(float name)

	Фабричность более эластчна(позволяет легко расширить множество поддерживаемых типов) - контроль правильности runtime
	Повышенная роль документации и её актуальность. Алгоритм централизован, изменения в одном месте.

	Перегрузки контролируют на этапе компиляции, ошибки видно сразу, уменьшается роль документации. 
	Добавление новых типов требует описание новых методов. Если организация не качествена, то алгоритмы распределенны и измененич прийдется повторять
	во всех методах


Рефакоринг - если код присутсвует во всех блоках - его нужно вынести
Рефакторинг - соединение(перераспределение) условий


/// <summary>
        /// Calculate sum of rn1 and rn2
        /// Where rn's  types are: int, String, RomanNumber
        /// </summary>
        /// <param name="rn1">int, String, RomanNumber</param>
        /// <param name="rn2">int, String, RomanNumber</param>
        /// <returns>RomanNumber</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public static RomanNumber Add(object rn1, object rn2)
        {
            /*  Рефакторинг - разделение условий (условия внутри условия)
            if (rn1 is null || rn2 is null)
            {
                throw new ArgumentNullException(
                    rn1 is null ? nameof(rn1) : nameof(rn2)) ;
            }*/
            if (rn1 is null) throw new ArgumentNullException(nameof(rn1));
            if (rn2 is null) throw new ArgumentNullException(nameof(rn2));



           /* Рефакторинг - соединение (перераспределение) условий
            if (rn1 is int && rn2 is int) return new RomanNumber((int)rn1).Add((int)rn2);
            else if (rn1 is String && rn2 is String) return new RomanNumber(RomanNumber.Parse((String)rn1)).Add((String)rn2);
            else if (rn1 is int && rn2 is String) return new RomanNumber((int)rn1).Add((String)rn2);
            else if (rn1 is String && rn2 is int) return new RomanNumber((int)rn2).Add((String)rn1);
            
             (rn1 is int && rn2 is int) + (rn1 is int && rn2 is String) -->
            (rn1 is int)(  rn2 is int  + rn2 is String )
             */
            if(rn1 is int v1)
            {
                /* Рефакторинг - если код присутствует во всех блоках, его нужно вынести
                if(rn2 is int v2) return new RomanNumber(v1).Add(v2);
                if(rn2 is String s2) return new RomanNumber(v1).Add(s2);
                */
                var rn = new RomanNumber(v1);
                if (rn2 is int v2) return rn.Add(v2);
                if (rn2 is String s2) return rn.Add(s2);
            }




            return new RomanNumber();
        }





		-------------

		public static RomanNumber Add(object obj1, object obj2)
        {
            if (obj1 is null) throw new ArgumentNullException(nameof(obj1));
            if (obj2 is null) throw new ArgumentNullException(nameof(obj2));
            RomanNumber rn1, rn2;
            if (obj1 is int val1) rn1 = new RomanNumber(val1);
            else if (obj1 is String str1) rn1 = new RomanNumber(Parse(str1));
            else if (obj1 is RomanNumber rn) rn1 = rn;
            else throw new ArgumentException("obj1: type unsupported");



           if (obj2 is int val2) rn2 = new RomanNumber(val2);
            else if (obj2 is String str2) rn2 = new RomanNumber(Parse(str2));
            else if (obj2 is RomanNumber rn) rn2 = rn;
            else throw new ArgumentException("obj2: type unsupported");



           return rn1.Add(rn2);
        }
		----------------

		public static RomanNumber Add(object obj1, object obj2)
        {
            var rns = new RomanNumber[] { null!, null! };
            var pars = new object[] { obj1, obj2 };



           for (int i = 0; i < 2; i++)
            {
                if (pars[i] is null) throw new ArgumentNullException($"obj{i+1}");



               if (pars[i] is int val) rns[i] = new RomanNumber(val);
                else if (pars[i] is String str) rns[i] = new RomanNumber(Parse(str));
                else if (pars[i] is RomanNumber rn) rns[i] = rn;
                else throw new ArgumentException($"obj{i+1}: type unsupported");
            }            



           return rns[0].Add(rns[1]);

		   ///
			   for(int i = 0 ; i < 2; i++)
			   {
					return rns[i].Add(rns[i-1]);
			   }
			////
        }

		------------------

	Магические значения - ресурсы - константы
	Магические (Hardcoded) значения - значения (числа, строки,массивы), которые появляются в коде

	В любом случае от таких значений нужно избавляться, !!!в коде должен быть только код!!!. Все значения, кроме 0, должны быть перемещены 
	в "секцию данных".

	1. В коде просматриваются строки с сообщением об исключениях, их нужно переносить

	Строки-константы
	Строки  с плейсхолдерами - строки, часть которых формируется в коде (throw new ArgumentException($"Invalid char {digit}");) --> "Invalid char %c"(шаблон строки, подставляем вместо знака нужное)
		const String empty_string = "Empty string not allowed";
        const String invalid_char = "Invalid char %";
        const String unsupported_type = $"obj D : type unsupported";

	2.Создаем объект-поставщик ресурсов, это позволит сгруппировать ресурсы разных классов - не искать их раздельно, а иметь единный ресурс
		public class Resources
		{
			...
		}

	Идея ресурсов позволяет использовать гарантированно одинаковые ресурсы в разных классах приложения; менять значения ресурсов одновременно для всех участников;
	использовать в тестах ссылки на ресурсы; внедрять локализацию/глобализацию - значения ресурсов для разных культур; 

	Культура - указание локализации в виде xx-XX
	xx - код языка
	XX - код страны
	код языка - ISO 639 - 1
	код страны - ISO 3166-1
	пример: uk-UA, ru-UA